---
title: "octostep"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment=NA)
source('https://github.com/chiefBiiko/octostep/raw/master/octostep.R')
```

Iterate lists getting a *window* argument list to your callback.

## API

```{r eval=FALSE}
octostep(x, func,  # x and func are required
         pad=1L, use.names=TRUE, transform.previous=FALSE)
```
+ `x` List, must conform to `length(x) >= 3L` **required**
+ `func` Function with arity `2L * pad + 1L` **required**
+ `pad` Integer controlling the number of items to be padded *around* (on each side of) the current item, must be within `1L:((length(x) - 1L) / 2L)` **optional**
+ `use.names` Copy names? **optional**
+ `transform.previous` Should the previous arguments to `func` hold the values of previous callbacks rather than the plain values of the initial input list? **optional**

### Return

List.

## Examples

```{r}
# see arguments evolve
octo <- octostep(as.list(1L:3L), function(pre, cur, nxt) {
  c(pre=if (is.null(pre)) NA else pre, 
    cur=cur, 
    nxt=if (is.null(nxt)) NA else nxt)
})

print(octo)
```

```{r}
# increased padding
paddle <- octostep(as.list(1L:5L), function(pre1, pre2, cur, nxt1, nxt2) {
  c(pre1=if (is.null(pre1)) NA else pre1, 
    pre2=if (is.null(pre2)) NA else pre2, 
    cur=cur, 
    nxt1=if (is.null(nxt1)) NA else nxt1,
    nxt2=if (is.null(nxt2)) NA else nxt2)
}, pad=2L)

print(paddle)
```

```{r}
# new input
cable <- list(m=0L, o=0L, n=4L, e=1L, y=9L)

# iterate and map with default options
mule <- octostep(cable, function(pre, cur, nxt) {
  if (!any.null(pre, nxt)) sum(pre, cur, nxt) else cur
}, pad=1L, use.names=TRUE, transform.previous=FALSE)  # all defaults

print(mule)
```

```{r}
# transform previous items while iterating
mutant <- octostep(cable, function(pre, cur, nxt) {
  if (!any.null(pre, nxt)) sum(pre, cur, nxt) else cur
}, pad=1L, use.names=TRUE, transform.previous=TRUE)

print(mutant)
```
